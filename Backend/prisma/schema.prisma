generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String                  @id @default(uuid())
  email                  String                  @unique
  name                   String?
  password               String?
  role                   UserRole                @default(USER)
  createdAt              DateTime                @default(now())
  managedBrands          Brand[]                 @relation("BrandManager")
  complaints             Complaint[]
  followups              Followup[]
  notifications          Notification[]
  notificationPreference NotificationPreference?
  brandMemberships       BrandMember[]
  ratings                Rating[]
  verificationRequests   VerifiedRequest[]
  verifiedSubscriptions  VerifiedSubscription[]
}

model Brand {
  id           String           @id @default(uuid())
  name         String           @unique
  isVerified   Boolean          @default(false)
  createdAt    DateTime         @default(now())
  logoUrl      String?
  managerId    String?
  description  String?
  searchTags   String[]         @default([])
  supportEmail String?
  supportPhone String?
  websiteUrl   String?
  manager      User?            @relation("BrandManager", fields: [managerId], references: [id])
  complaints   Complaint[]
  reputation   ReputationScore?
  subscriptions BrandSubscription[]
  billingProfile BrandBillingProfile?
  invoices       Invoice[]
  verificationRequests VerifiedRequest[]
  alertPreference      BrandAlertPreference?
  members              BrandMember[]
}

model BrandMember {
  id        String   @id @default(uuid())
  brandId   String
  userId    String
  role      String   @default("ADMIN") // ADMIN, EDITOR, VIEWER
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  brand Brand @relation(fields: [brandId], references: [id])
  user  User  @relation(fields: [userId], references: [id])

  @@unique([brandId, userId])
}

model BrandAlertPreference {
  id                  String   @id @default(uuid())
  brandId             String   @unique
  emailEnabled        Boolean  @default(true)
  inAppEnabled        Boolean  @default(true)
  complaintCreated    Boolean  @default(true)
  escalations         Boolean  @default(true)
  newMessages         Boolean  @default(true)
  statusChanges       Boolean  @default(false)
  evidenceAdded       Boolean  @default(false)
  dailyDigestEnabled  Boolean  @default(false)
  digestTimeLocal     String? // "08:00"
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  brand               Brand    @relation(fields: [brandId], references: [id])
}

model EmailOutbox {
  id        String    @id @default(uuid())
  brandId   String
  toEmail   String
  subject   String
  htmlBody  String
  textBody  String?
  status    String    @default("PENDING") // PENDING | SENT | FAILED
  attempts  Int       @default(0)
  lastError String?
  createdAt DateTime  @default(now())
  sentAt    DateTime?

  @@index([brandId])
}

enum NotificationType {
  COMPLAINT_CREATED
  COMPLAINT_ESCALATED
  NEW_CONSUMER_MESSAGE
  STATUS_CHANGED
  EVIDENCE_ADDED
  SYSTEM_ALERT
}

enum DeliveryChannel {
  IN_APP
  EMAIL
}

model SubscriptionPlan {
  id           String              @id @default(uuid())
  code         String              @unique
  name         String
  monthlyPrice Int
  features     Json
  createdAt    DateTime            @default(now())
  subscriptions BrandSubscription[]
}

model BrandSubscription {
  id         String             @id @default(uuid())
  brandId    String
  planId     String
  status     SubscriptionStatus
  startedAt  DateTime
  endsAt     DateTime?
  gatewayRef String?
  createdAt  DateTime           @default(now())

  brand Brand            @relation(fields: [brandId], references: [id])
  plan  SubscriptionPlan @relation(fields: [planId], references: [id])
  transactions PaymentTransaction[]

  @@unique([brandId, planId])
}

model PaymentTransaction {
  id             String            @id @default(uuid())
  brandId        String
  subscriptionId String
  amount         Int
  currency       String
  gateway        String
  gatewayRef     String
  status         String
  createdAt      DateTime          @default(now())
  subscription   BrandSubscription @relation(fields: [subscriptionId], references: [id])
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELLED
  EXPIRED
}

model BrandBillingProfile {
  id             String   @id @default(uuid())
  brandId        String   @unique
  legalName      String
  registrationNo String?
  vatNumber      String?
  billingEmail   String
  addressLine1   String
  addressLine2   String?
  city           String
  province       String
  postalCode     String
  country        String   @default("South Africa")
  createdAt      DateTime @default(now())
  brand          Brand    @relation(fields: [brandId], references: [id])
}

model Invoice {
  id             String        @id @default(uuid())
  invoiceNumber  String        @unique
  brandId        String
  subscriptionId String?
  subtotal       Int
  vatAmount      Int
  total          Int
  currency       String        @default("ZAR")
  status         InvoiceStatus
  issuedAt       DateTime
  dueDate        DateTime?
  paidAt         DateTime?
  brand          Brand         @relation(fields: [brandId], references: [id])
  items          InvoiceItem[]
}
  
model InvoiceItem {
  id          String  @id @default(uuid())
  invoiceId   String
  description String
  quantity    Int     @default(1)
  unitPrice   Int     // In cents
  amount      Int     // quantity * unitPrice
  
  invoice     Invoice @relation(fields: [invoiceId], references: [id])
}

enum InvoiceStatus {
  ISSUED
  PAID
  VOID
}

model VerifiedRequest {
  id            String             @id @default(uuid())
  brandId       String
  userId        String
  companyName   String
  documents     Json               // List of files/metadata
  status        VerificationStatus @default(PENDING)
  adminComments String?
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt

  brand                Brand                  @relation(fields: [brandId], references: [id])
  user                 User                   @relation(fields: [userId], references: [id])
  verifiedSubscription VerifiedSubscription[]
}

enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED
}

model VerifiedSubscription {
  id                String            @id @default(uuid())
  userId            String
  verifiedRequestId String
  status            VerifiedSubStatus @default(PENDING)
  paymentGateway    String?
  paymentReference  String?
  amount            Decimal?          @db.Decimal(12, 2)
  vat               Decimal?          @db.Decimal(5, 2)
  startDate         DateTime?
  endDate           DateTime?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  user            User            @relation(fields: [userId], references: [id])
  verifiedRequest VerifiedRequest @relation(fields: [verifiedRequestId], references: [id])
}

enum VerifiedSubStatus {
  PENDING
  ACTIVE
  EXPIRED
  CANCELLED
}

model VerificationAuditLog {
  id             String   @id @default(uuid())
  verificationId String
  brandId        String
  adminId        String
  action         String
  reason         String?
  createdAt      DateTime @default(now())
}

model AdminAuditLog {
  id        String   @id @default(uuid())
  adminId   String
  action    String
  entity    String
  entityId  String?
  metadata  Json?
  createdAt DateTime @default(now())
}

model Complaint {
  id             String                   @id @default(uuid())
  userId         String
  brandId        String
  title          String
  description    String
  status         ComplaintStatus          @default(DRAFT)
  aiSummary      String?
  sentimentScore Float?
  verifiedTier   Int                      @default(3)
  createdAt      DateTime                 @default(now())
  updatedAt      DateTime                 @updatedAt
  attachments    Attachment[]
  brand          Brand                    @relation(fields: [brandId], references: [id])
  user           User                     @relation(fields: [userId], references: [id])
  statusHistory  ComplaintStatusHistory[]
  followups      Followup[]
  ratings        Rating[]
  escalationCase EscalationCase?
}

model ReputationScore {
  id        String   @id @default(uuid())
  brandId   String   @unique
  score     Float
  updatedAt DateTime @updatedAt
  brand     Brand    @relation(fields: [brandId], references: [id])
}

model ComplaintCluster {
  id        String   @id @default(uuid())
  brandId   String
  keyword   String
  count     Int
  windowHr  Int
  createdAt DateTime @default(now())
}

model Attachment {
  id          String    @id @default(uuid())
  complaintId String
  fileName    String
  mimeType    String
  size        Int
  createdAt   DateTime  @default(now())
  complaint   Complaint @relation(fields: [complaintId], references: [id])
}

model ComplaintStatusHistory {
  id          String          @id @default(uuid())
  complaintId String
  fromStatus  ComplaintStatus
  toStatus    ComplaintStatus
  changedBy   String
  createdAt   DateTime        @default(now())
  complaint   Complaint       @relation(fields: [complaintId], references: [id])
}

model MFA {
  id        String   @id @default(uuid())
  userId    String   @unique
  secret    String
  enabled   Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AuditLog {
  id        String   @id @default(uuid())
  entity    String
  entityId  String
  action    String
  actorId   String
  metadata  Json
  createdAt DateTime @default(now())
}

model Rating {
  id          String    @id @default(uuid())
  userId      String
  complaintId String
  stars       Int
  comment     String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  complaint   Complaint @relation(fields: [complaintId], references: [id])
  user        User      @relation(fields: [userId], references: [id])

  @@unique([userId, complaintId])
}

model Notification {
  id        String   @id @default(uuid())
  userId    String?  // targeted recipient (consumer or specific brand member)
  brandId   String?  // brand context for brand notifications
  type      String   // Can be NotificationType enum values as strings
  title     String
  body      String
  link      String?
  metadata  Json?
  read      Boolean  @default(false)
  priority  String   @default("info")
  createdAt DateTime @default(now())
  readAt    DateTime?

  user      User?    @relation(fields: [userId], references: [id])

  @@index([userId, read, createdAt])
  @@index([brandId, read, createdAt])
}

model NotificationPreference {
  id           String  @id @default(uuid())
  userId       String  @unique
  emailEnabled Boolean @default(true)
  pushEnabled  Boolean @default(true)
  user         User    @relation(fields: [userId], references: [id])
}

model Followup {
  id          String    @id @default(uuid())
  complaintId String
  userId      String
  comment     String
  createdAt   DateTime  @default(now())
  complaint   Complaint @relation(fields: [complaintId], references: [id])
  user        User      @relation(fields: [userId], references: [id])
  authenticityScore ResponderAuthenticityScore?
}

model BrandClaim {
  id         String           @id @default(uuid())
  userId     String
  brandName  String
  email      String
  status     BrandClaimStatus @default(PENDING)
  aiScore    Int?
  documents  String[]
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
  websiteUrl String?
}

enum ComplaintStatus {
  DRAFT
  SUBMITTED
  UNDER_REVIEW
  NEEDS_INFO
  INFO_PROVIDED
  RESPONDED
  RESOLVED
  REJECTED
}

enum UserRole {
  USER
  MODERATOR
  ADMIN
  SUPER_ADMIN
  BRAND
  FINANCE
  AUDITOR
}

enum BrandClaimStatus {
  PENDING
  APPROVED
  REJECTED
  INFO_REQUESTED
}

model ResponderAuthenticityScore {
  id              String   @id @default(uuid())
  responseId      String   @unique
  businessUserId  String
  identityScore   Float
  behaviorScore   Float
  languageScore   Float
  reputationScore Float
  compositeScore  Float
  riskBand        String   // LOW | MEDIUM | HIGH
  ruleBreakdown   Json
  createdAt       DateTime @default(now())
  
  response        Followup @relation(fields: [responseId], references: [id])
}

model TrustScore {
  id         String   @id @default(uuid())
  entityType String   // "USER" | "BRAND"
  entityId   String
  score      Int      // 0-100
  riskLevel  String   // LOW | MEDIUM | HIGH | CRITICAL
  metadata   Json?    // Stores breakdown factors: { authenticity, activity, verification }
  evaluatedAt DateTime @default(now())

  @@index([entityType, entityId])
}

model EnforcementAction {
  id          String   @id @default(uuid())
  entityType  String
  entityId    String
  actionType  String   // WARNING, RATE_LIMIT, REVIEW_REQUIRED, TEMP_RESTRICTION
  reason      String
  triggeredBy String   // AI_RULE_ID or ADMIN
  createdAt   DateTime @default(now())
  resolvedAt  DateTime?
}

model EscalationCase {
  id            String   @id @default(uuid())
  complaintId   String   @unique
  escalatedBy   String   // USER | SYSTEM | ADMIN
  reason        String
  aiRiskSummary String?
  status        String   // PENDING | INVESTIGATING | RESOLVED | REFERRED
  createdAt     DateTime @default(now())
  
  complaint     Complaint @relation(fields: [complaintId], references: [id])
}

enum SentimentLabel {
  VERY_NEGATIVE
  NEGATIVE
  NEUTRAL
  POSITIVE
  VERY_POSITIVE
}

enum SentimentSourceType {
  COMPLAINT
  BRAND_RESPONSE
  CONSUMER_MESSAGE
  SYSTEM_NOTE
  RATING
}

model SentimentEvent {
  id                String              @id @default(uuid())
  brandId           String
  complaintId       String?
  sourceType        SentimentSourceType
  sourceId          String?             // messageId, responseId, etc
  textHash          String
  language          String?             // "en", "af", etc
  stars             Int?                // for RATING source
  label             SentimentLabel
  score             Float               // -1.0 to +1.0
  intensity         Float               // 0.0 to 1.0
  urgency           Int                 // 0 to 100
  topics            String[]            // ["billing","delivery"]
  keyPhrases        String[]            // short phrases

  model             String
  provider          String              @default("openai")
  moderationFlagged Boolean             @default(false)
  moderationRaw     Json?
  raw               Json?               // full structured output + reasoning metadata
  createdAt         DateTime            @default(now())

  @@index([brandId])
  @@index([complaintId])
  @@index([sourceId])
  @@index([textHash])
  @@index([brandId, createdAt])
}

model BrandSentimentDaily {
  id          String   @id @default(uuid())
  brandId     String
  day         DateTime // store midnight UTC
  count       Int
  avgScore    Float
  avgUrgency  Float
  avgStars    Float?
  positivePct Float
  negativePct Float
  neutralPct  Float
  topTopics   String[]
  updatedAt   DateTime @updatedAt

  @@index([brandId])
  @@index([day])
  @@unique([brandId, day])
}

model ComplaintSentimentSnapshot {
  id             String         @id @default(uuid())
  complaintId    String         @unique
  brandId        String
  lastEventAt    DateTime
  currentLabel   SentimentLabel
  currentScore   Float
  currentUrgency Int
  topics         String[]
  updatedAt      DateTime       @updatedAt

  @@index([brandId])
}


