generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x", "debian-openssl-3.0.x", "linux-musl", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String                  @id @default(uuid())
  email                  String                  @unique
  name                   String?
  password               String?
  role                   UserRole                @default(USER)
  createdAt              DateTime                @default(now())
  managedBrands          Brand[]                 @relation("BrandManager")
  brandMemberships       BrandMember[]
  assignedComplaints     Complaint[]             @relation("ComplaintAssignee")
  complaints             Complaint[]
  followups              Followup[]
  notifications          Notification[]
  notificationPreference NotificationPreference?
  ratings                Rating[]
  verificationRequests   VerifiedRequest[]
  verifiedSubscriptions  VerifiedSubscription[]
}

model Brand {
  id                   String                @id @default(uuid())
  name                 String                @unique
  isVerified           Boolean               @default(false)
  createdAt            DateTime              @default(now())
  logoUrl              String?
  description          String?
  managerId            String?
  searchTags           String[]              @default([])
  supportEmail         String?
  supportPhone         String?
  websiteUrl           String?
  category             String?               @default("General")
  allowedDomains       String[]              @default([])
  defaultTheme         String                @default("light")
  googlePlaceId        String?
  googleReviewUrl      String?
  slug                 String?               @unique
  widgetPlan           WidgetPlan            @default(FREE)
  widgetRoutingEnabled Boolean               @default(true)
  widgetWatermark      Boolean               @default(true)
  widgetStyles         Json?
  widgetWatermarkText  String?
  manager              User?                 @relation("BrandManager", fields: [managerId], references: [id])
  alertPreference      BrandAlertPreference?
  billingProfile       BrandBillingProfile?
  dailyMetrics         BrandDailyMetrics[]
  locations            BrandLocation[]
  members              BrandMember[]
  slaConfig            BrandSLAConfig?
  subscriptions        BrandSubscription[]
  complaints           Complaint[]
  invoices             Invoice[]
  reputation           ReputationScore?
  verificationRequests VerifiedRequest[]
  widgetKeys           WidgetKey[]
}

model BrandMember {
  id        String   @id @default(uuid())
  brandId   String
  userId    String
  role      String   @default("ADMIN")
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  brand     Brand    @relation(fields: [brandId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([brandId, userId])
}

model BrandAlertPreference {
  id                 String   @id @default(uuid())
  brandId            String   @unique
  emailEnabled       Boolean  @default(true)
  inAppEnabled       Boolean  @default(true)
  complaintCreated   Boolean  @default(true)
  escalations        Boolean  @default(true)
  newMessages        Boolean  @default(true)
  statusChanges      Boolean  @default(false)
  evidenceAdded      Boolean  @default(false)
  dailyDigestEnabled Boolean  @default(false)
  digestTimeLocal    String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  brand              Brand    @relation(fields: [brandId], references: [id])
}

model EmailOutbox {
  id        String    @id @default(uuid())
  brandId   String
  toEmail   String
  subject   String
  htmlBody  String
  textBody  String?
  status    String    @default("PENDING")
  attempts  Int       @default(0)
  lastError String?
  createdAt DateTime  @default(now())
  sentAt    DateTime?

  @@index([brandId])
}

model SubscriptionPlan {
  id            String              @id @default(uuid())
  code          String              @unique
  name          String
  monthlyPrice  Int
  features      Json
  createdAt     DateTime            @default(now())
  subscriptions BrandSubscription[]
}

model BrandSubscription {
  id           String               @id @default(uuid())
  brandId      String
  planId       String
  status       SubscriptionStatus
  startedAt    DateTime
  endsAt       DateTime?
  gatewayRef   String?
  createdAt    DateTime             @default(now())
  brand        Brand                @relation(fields: [brandId], references: [id])
  plan         SubscriptionPlan     @relation(fields: [planId], references: [id])
  transactions PaymentTransaction[]

  @@unique([brandId, planId])
}

model PaymentTransaction {
  id             String            @id @default(uuid())
  brandId        String
  subscriptionId String
  amount         Int
  currency       String
  gateway        String
  gatewayRef     String
  status         String
  createdAt      DateTime          @default(now())
  subscription   BrandSubscription @relation(fields: [subscriptionId], references: [id])
}

model BrandBillingProfile {
  id             String   @id @default(uuid())
  brandId        String   @unique
  legalName      String
  registrationNo String?
  vatNumber      String?
  billingEmail   String
  addressLine1   String
  addressLine2   String?
  city           String
  province       String
  postalCode     String
  country        String   @default("South Africa")
  createdAt      DateTime @default(now())
  brand          Brand    @relation(fields: [brandId], references: [id])
}

model Invoice {
  id             String        @id @default(uuid())
  invoiceNumber  String        @unique
  brandId        String
  subscriptionId String?
  subtotal       Int
  vatAmount      Int
  total          Int
  currency       String        @default("ZAR")
  status         InvoiceStatus
  issuedAt       DateTime
  paidAt         DateTime?
  dueDate        DateTime?
  brand          Brand         @relation(fields: [brandId], references: [id])
  items          InvoiceItem[]
}

model InvoiceItem {
  id          String  @id @default(uuid())
  invoiceId   String
  description String
  quantity    Int     @default(1)
  unitPrice   Int
  amount      Int
  invoice     Invoice @relation(fields: [invoiceId], references: [id])
}

model VerifiedRequest {
  id                   String                 @id @default(uuid())
  brandId              String
  userId               String
  companyName          String
  documents            Json
  status               VerificationStatus     @default(PENDING)
  adminComments        String?
  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @updatedAt
  brand                Brand                  @relation(fields: [brandId], references: [id])
  user                 User                   @relation(fields: [userId], references: [id])
  verifiedSubscription VerifiedSubscription[]
}

model VerifiedSubscription {
  id                String            @id @default(uuid())
  userId            String
  verifiedRequestId String
  status            VerifiedSubStatus @default(PENDING)
  paymentGateway    String?
  paymentReference  String?
  amount            Decimal?          @db.Decimal(12, 2)
  vat               Decimal?          @db.Decimal(5, 2)
  startDate         DateTime?
  endDate           DateTime?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  user              User              @relation(fields: [userId], references: [id])
  verifiedRequest   VerifiedRequest   @relation(fields: [verifiedRequestId], references: [id])
}

model VerificationAuditLog {
  id             String   @id @default(uuid())
  verificationId String
  brandId        String
  adminId        String
  action         String
  reason         String?
  createdAt      DateTime @default(now())
}

model AdminAuditLog {
  id        String   @id @default(uuid())
  adminId   String
  action    String
  entity    String
  entityId  String?
  metadata  Json?
  createdAt DateTime @default(now())
}

model Complaint {
  id             String                   @id @default(uuid())
  userId         String
  brandId        String
  title          String
  description    String
  status         ComplaintStatus          @default(DRAFT)
  aiSummary      String?
  sentimentScore Float?
  verifiedTier   Int                      @default(3)
  createdAt      DateTime                 @default(now())
  updatedAt      DateTime                 @updatedAt
  lastRemindedAt DateTime?
  assignedToId   String?
  slaDeadline    DateTime?
  slaStatus      SLAStatus                @default(ON_TRACK)
  attachments    Attachment[]
  assignedTo     User?                    @relation("ComplaintAssignee", fields: [assignedToId], references: [id])
  brand          Brand                    @relation(fields: [brandId], references: [id])
  user           User                     @relation(fields: [userId], references: [id])
  statusHistory  ComplaintStatusHistory[]
  escalationCase EscalationCase?
  followups      Followup[]
  ratings        Rating[]
}

model ReputationScore {
  id        String   @id @default(uuid())
  brandId   String   @unique
  score     Float
  updatedAt DateTime @updatedAt
  brand     Brand    @relation(fields: [brandId], references: [id])
}

model ComplaintCluster {
  id        String   @id @default(uuid())
  brandId   String
  keyword   String
  count     Int
  windowHr  Int
  createdAt DateTime @default(now())
}

model Attachment {
  id          String    @id @default(uuid())
  complaintId String
  fileName    String
  mimeType    String
  size        Int
  createdAt   DateTime  @default(now())
  complaint   Complaint @relation(fields: [complaintId], references: [id])
}

model ComplaintStatusHistory {
  id          String          @id @default(uuid())
  complaintId String
  fromStatus  ComplaintStatus
  toStatus    ComplaintStatus
  changedBy   String
  createdAt   DateTime        @default(now())
  complaint   Complaint       @relation(fields: [complaintId], references: [id])
}

model MFA {
  id        String   @id @default(uuid())
  userId    String   @unique
  secret    String
  enabled   Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AuditLog {
  id        String   @id @default(uuid())
  entity    String
  entityId  String
  action    String
  actorId   String
  metadata  Json
  createdAt DateTime @default(now())
}

model Rating {
  id          String    @id @default(uuid())
  userId      String
  complaintId String
  stars       Int
  comment     String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  complaint   Complaint @relation(fields: [complaintId], references: [id])
  user        User      @relation(fields: [userId], references: [id])

  @@unique([userId, complaintId])
}

model Notification {
  id        String    @id @default(uuid())
  userId    String?
  type      String
  read      Boolean   @default(false)
  priority  String    @default("info")
  createdAt DateTime  @default(now())
  body      String
  brandId   String?
  link      String?
  metadata  Json?
  readAt    DateTime?
  title     String
  user      User?     @relation(fields: [userId], references: [id])

  @@index([userId, read, createdAt])
  @@index([brandId, read, createdAt])
}

model NotificationPreference {
  id           String  @id @default(uuid())
  userId       String  @unique
  emailEnabled Boolean @default(true)
  pushEnabled  Boolean @default(true)
  user         User    @relation(fields: [userId], references: [id])
}

model Followup {
  id                String                      @id @default(uuid())
  complaintId       String
  userId            String
  comment           String
  createdAt         DateTime                    @default(now())
  complaint         Complaint                   @relation(fields: [complaintId], references: [id])
  user              User                        @relation(fields: [userId], references: [id])
  authenticityScore ResponderAuthenticityScore?
}

model BrandClaim {
  id         String           @id @default(uuid())
  userId     String
  brandName  String
  email      String
  status     BrandClaimStatus @default(PENDING)
  aiScore    Int?
  documents  String[]
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
  websiteUrl String?
}

model ResponderAuthenticityScore {
  id              String   @id @default(uuid())
  responseId      String   @unique
  businessUserId  String
  identityScore   Float
  behaviorScore   Float
  languageScore   Float
  reputationScore Float
  compositeScore  Float
  riskBand        String
  ruleBreakdown   Json
  createdAt       DateTime @default(now())
  response        Followup @relation(fields: [responseId], references: [id])
}

model TrustScore {
  id          String   @id @default(uuid())
  entityType  String
  entityId    String
  score       Int
  riskLevel   String
  metadata    Json?
  evaluatedAt DateTime @default(now())

  @@index([entityType, entityId])
}

model EnforcementAction {
  id          String    @id @default(uuid())
  entityType  String
  entityId    String
  actionType  String
  reason      String
  triggeredBy String
  createdAt   DateTime  @default(now())
  resolvedAt  DateTime?
}

model EscalationCase {
  id            String    @id @default(uuid())
  complaintId   String    @unique
  escalatedBy   String
  reason        String
  aiRiskSummary String?
  status        String
  createdAt     DateTime  @default(now())
  complaint     Complaint @relation(fields: [complaintId], references: [id])
}

model SentimentEvent {
  id                String              @id @default(uuid())
  brandId           String
  complaintId       String?
  sourceType        SentimentSourceType
  sourceId          String?
  textHash          String
  language          String?
  label             SentimentLabel
  score             Float
  intensity         Float
  urgency           Int
  topics            String[]
  keyPhrases        String[]
  model             String
  provider          String              @default("openai")
  moderationFlagged Boolean             @default(false)
  moderationRaw     Json?
  raw               Json?
  createdAt         DateTime            @default(now())
  stars             Int?

  @@index([brandId])
  @@index([complaintId])
  @@index([sourceId])
  @@index([textHash])
  @@index([brandId, createdAt])
}

model BrandSentimentDaily {
  id          String   @id @default(uuid())
  brandId     String
  day         DateTime
  count       Int
  avgScore    Float
  avgUrgency  Float
  positivePct Float
  negativePct Float
  neutralPct  Float
  topTopics   String[]
  updatedAt   DateTime @updatedAt
  avgStars    Float?

  @@unique([brandId, day])
  @@index([brandId])
  @@index([day])
}

model ComplaintSentimentSnapshot {
  id             String         @id @default(uuid())
  complaintId    String         @unique
  brandId        String
  lastEventAt    DateTime
  currentLabel   SentimentLabel
  currentScore   Float
  currentUrgency Int
  topics         String[]
  updatedAt      DateTime       @updatedAt

  @@index([brandId])
}

model BrandSLAConfig {
  id                    String   @id @default(uuid())
  brandId               String   @unique
  lowPriorityHours      Int      @default(48)
  mediumPriorityHours   Int      @default(24)
  highPriorityHours     Int      @default(4)
  criticalPriorityHours Int      @default(1)
  updatedAt             DateTime @updatedAt
  brand                 Brand    @relation(fields: [brandId], references: [id])
}

model BrandLocation {
  id            String              @id @default(cuid())
  brandId       String
  name          String
  slug          String
  googlePlaceId String?
  isActive      Boolean             @default(true)
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  metrics       BrandDailyMetrics[]
  brand         Brand               @relation(fields: [brandId], references: [id], onDelete: Cascade)

  @@unique([brandId, slug])
}

model WidgetKey {
  id         String    @id @default(cuid())
  brandId    String
  key        String    @unique
  isActive   Boolean   @default(true)
  createdAt  DateTime  @default(now())
  lastUsedAt DateTime?
  brand      Brand     @relation(fields: [brandId], references: [id], onDelete: Cascade)
}

model BrandDailyMetrics {
  id                         String         @id @default(cuid())
  brandId                    String
  locationId                 String?
  date                       DateTime
  complaintsOpened           Int            @default(0)
  complaintsResolved         Int            @default(0)
  responseRatePct            Float          @default(0)
  medianFirstResponseMinutes Int            @default(0)
  medianResolutionMinutes    Int            @default(0)
  trustScore                 Int            @default(0)
  sentimentAvg               Float          @default(0)
  sentimentDelta30d          Float          @default(0)
  createdAt                  DateTime       @default(now())
  updatedAt                  DateTime       @updatedAt
  brand                      Brand          @relation(fields: [brandId], references: [id], onDelete: Cascade)
  location                   BrandLocation? @relation(fields: [locationId], references: [id])

  @@unique([brandId, locationId, date])
  @@index([brandId, date])
  @@index([brandId, locationId, date])
}

enum WidgetPlan {
  FREE
  PRO
  BUSINESS
  ENTERPRISE
}

enum NotificationType {
  COMPLAINT_CREATED
  COMPLAINT_ESCALATED
  NEW_CONSUMER_MESSAGE
  STATUS_CHANGED
  EVIDENCE_ADDED
  SYSTEM_ALERT
}

enum DeliveryChannel {
  IN_APP
  EMAIL
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELLED
  EXPIRED
}

enum InvoiceStatus {
  ISSUED
  PAID
  VOID
}

enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED
}

enum VerifiedSubStatus {
  PENDING
  ACTIVE
  EXPIRED
  CANCELLED
}

enum ComplaintStatus {
  DRAFT
  SUBMITTED
  UNDER_REVIEW
  NEEDS_INFO
  RESPONDED
  RESOLVED
  REJECTED
  INFO_PROVIDED
}

enum UserRole {
  USER
  MODERATOR
  ADMIN
  SUPER_ADMIN
  BRAND
  FINANCE
  AUDITOR
}

enum BrandClaimStatus {
  PENDING
  APPROVED
  REJECTED
  INFO_REQUESTED
}

enum SentimentLabel {
  VERY_NEGATIVE
  NEGATIVE
  NEUTRAL
  POSITIVE
  VERY_POSITIVE
}

enum SentimentSourceType {
  COMPLAINT
  BRAND_RESPONSE
  CONSUMER_MESSAGE
  SYSTEM_NOTE
  RATING
}

enum SLAStatus {
  ON_TRACK
  AT_RISK
  BREACHED
}
